#!/usr/bin/perl

# Copyright (c) 2020 Atomic Spuds <AtomicSpudsGame@gmail.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Data::Dumper;
use DBI qw(:sql_types);
use Getopt::Std;
use JSON;

use Common::Db;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_v = 0;
our $opt_s;
our $opt_c;

$opt_c = $ENV{'HOME'}."/.ee-api.conf";

getopt('c:s:v');

our $cacheinfo = { };
our $json = JSON->new->allow_nonref;
our $dbh;

if (! -f $opt_c) {
	die "config file '$opt_c' does not exist";
}

our $config = Config::Tiny->read( $opt_c );

my $cdb = Common::Db->new(
	'config' => $config,
);
$cdb->init;
exit(0);

our $lastfetch = 0;

my $apiurl = "https://api.eve-echoes-market.com/market-stats";

my $ri = get_data("${apiurl}/stats.csv");

my $csv = $ri->{data};

my $count = 0;
my @names;
my @data;
my $line;
my $sheet = { };
my $maxval = 0;
my $maxid;
my $maxname;
foreach my $l (split(/^/,$csv)) {
	chomp($line=$l);
	if ($count++ == 0) {
		#printf STDERR "1st line: '%s'\n",$line;
		(@names) = split(/,/,$line);
		my $ncount = 0;
		foreach my $n (@names) {
			#printf STDERR "title '%s' = %d\n",$n,$ncount;
			$sheet->{title}->{$n} = $ncount++;
		}
		next;
	}
	#printf STDERR "Processing line %d '%s'\n", $count, $line;
	@data = split(/,/,$line);
	my $idoff= $sheet->{title}->{item_id};
	my $id = $data[$idoff];
	my $nameoff = $sheet->{title}->{name};
	my $name = $data[$nameoff];

	if (defined($opt_s)) {
		if (! ($name =~ /$opt_s/)) {
			next;
		}
	}
			
	printf STDERR "${apiurl}/%s\n",$id;
	my $ri = get_data("${apiurl}/$id");

	my $parsed;
	eval {
		$parsed = $json->decode( $ri->{data} );
	};
	if ($@) {
		printf STDERR "json->decode() Error: %s\n", $@;
		next;
	}

	if ($opt_v>0) {
		#print $json->pretty->encode( $parsed );
	}
		printf "    ID         Time       Low   Sell      Buy    High   Volume\n";
		#      "10200000104 1599566400  500000 1000000   73500  300000   3.2

		foreach my $d (sort { $b->{time} <=> $a->{time} } @{$parsed}) {
			my $nd = { };

			foreach my $k (keys %{$d}) {
				if (!defined($d->{$k})) {
					#printf "d->{$k} is undefined?\n";
					$nd->{$k} = "null";
					next;
				}
				if ($d->{$k} eq "null") {
					$nd->{$k} = "null";
					next;
				}
				if ($k =~ /time/) {
					$nd->{$k} = $d->{$k};
					next;
				}
				if ($k =~ /(buy|sell)/) {
					if ($d->{$k} > $maxval) {
						$maxval = $d->{$k};
						$maxid  = $id;
						$maxname = $name;
					}
					$nd->{$k} = $d->{$k};
					next;
				}
				$nd->{$k} = sprintf("%7.2f",$d->{$k});
			}
				
			printf "%d %10s %11s %11s %11s %11s %6s\n",
				$id,
				$nd->{time},
				$nd->{lowest_sell},
				$nd->{sell},
				$nd->{buy},
				$nd->{highest_buy},
				$nd->{volume};
			#print Dumper($d);
			#exit(0);
		}

		#exit(0);
}
printf "Bonus info.. max val was a %s, value %s, id %d\n", $maxname, $maxval, $maxid;

1;

sub get_data {
	my ($url) = @_;

	my $ci = { };

	$ci->{key} = "$url";

	my $ri = cache($ci);

	if (defined($ri)) {
		return $ri;
	}

	# be gentle, don't spam, 3s delay ought to be kind enough
	my $delay=3;
	while ( ($lastfetch+$delay) > time() ) {
		sleep(1);
	}
	$lastfetch = time();

	$ci->{data} = "";

	my $line;
	open(D, "ftp -o - '${url}'|");
	while(<D>) {
		chomp($line = $_);
		$line =~ s/\xef\xbb\xbf//g;
		$line =~ s/\x0d//g; # THE carriage return char
		$ci->{data} .= "$line\n";
	}
	close(D);

	return cache($ci);
}

# XXX sync with git/sw/mm/mm and eventually break out to an api class

# cache($ciits)
#
#  my $ciits = { };
#  $ciits->{key} = "unique lookup key";
#  $ciits->{data} = $data;
#  $ciits->{ttl} = 86000; # seconds till cache entry expires

sub cache {
	my ($ci) = @_;

	if (!defined($cacheinfo->{hash})) {
		cache_setup();
	}

	my $ri = { };

	my $key = $ci->{key};
	my $hash = cache_str2hash($key);

	my $cdir = $cacheinfo->{cdir};
	my $hfile = "$cdir/$hash";
	my $mdfile = "${hfile}.md";

	if (!defined($ci->{data})) {
		if ($opt_v > 0) {
			print STDERR "cache read: ".$ci->{key}." from $hash\n";
		}

		if (! -f "$cdir/$hash") {
			if ($opt_v > 0) {
				print STDERR "cache read: ENOTFOUND\n";
			}
			return undef;
		}


		if (-f $mdfile) {
			open(M,"<",$mdfile);
			while(<M>) {
				chomp($ri->{key} = $_);
			}
			close(M);
		}
		if (!defined($ri->{key})) {
			$ri->{key} = $ci->{key};
		}
	
		$ri->{data} = "";
		open(H,"xz -d < $cdir/$hash|");
		while(<H>) {
			$ri->{data} .= $_;
		}
		close(H);
		if ($opt_v > 0) {
			printf STDERR "cache read: %d bytes\n", length($ri->{data});
		}
		return $ri;
	}

	if ($opt_v > 0) {
		print STDERR "cache write: ".$ci->{key}." to $hash\n";
	}

	# XXX temp for M, check for errors
	open(M, ">", ${mdfile});
	print M $ci->{key}."\n";
	close(M);

	open(H,"|xz -9e>$cdir/.${hash}");
	print H $ci->{data};
	close(H);

	rename("$cdir/.${hash}", "$cdir/$hash");

	if ($opt_v > 0) {
		printf STDERR "cache write: %d bytes\n", length($ci->{data});
	}

	$ri = { };
	$ri->{key} = $ci->{key};
	$ri->{data} = $ci->{data};

	return $ri;
}

sub cache_str2hash {
	my ($str) = @_;

	$cacheinfo->{hash}->add($str);
	my $res = $cacheinfo->{hash}->hexdigest;
	$cacheinfo->{hash}->reset;
	return $res;
}

sub cache_setup {
	use Crypt::Digest::SHA256;

	my $HOME=$ENV{'HOME'};
	my $cdir = "${HOME}/.cache/ee-api";
	if (! -d "${HOME}/.cache") {
		mkdir("${HOME}/.cache") || die
	}
	if (! -d $cdir) {
		mkdir($cdir);
	}

	$cacheinfo->{cdir} = $cdir;

	$cacheinfo->{hash} = Crypt::Digest::SHA256->new();
}

